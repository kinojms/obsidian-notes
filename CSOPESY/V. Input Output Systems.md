- I/O Management is a major component of OS design and operation
	- important aspect of computer operation
	- I/O devices can vary
	- various methods to control them
	- performance management (polling rate)
	- new types of devices frequent
- ports, busses, device controllers connect to various devicesâ€”these devices aren't directly connected to the processor, the **device drivers** are the ones connected to the processor
- **Device Drivers** - encapsulate device details
	- present uniform device-access interface to I/O subsystem
- incredible variety
	- storage
	- transmission
	- human-interface
- common concepts - signals from I/O devices interface with computer
	- port - connection point for device (not related to the networking kind of port)
	- bus - daisy chain or shared direct access
		- it's like a highway from the connection point to your processor
		- **bifurcation** - allows a single PCIe slot on a motherboard to be split into multiple smaller lane configurations
		- **controlled by the CPU**
- controller (host adapter) - electronics that operate port, bus, device
	- sometimes integrates
	- sometimes separate circuit board
		- in certain architecture, you might want to add additional NVMe's
	- contains processor, microcode, private memory, etc.
	- USB hubs are an example where it becomes a kind of multiplexer for external USB devices (multiple input - one output)
- Fibre channel (FC) is a complex controller, usually separate circuit board (host-bus adapter, HBA plugging into bus)
- I/O instructions control devices
- devices usually registers where device driver places commands, addresses, and data to write, or read data from registers after command execution
	- data-in register, data-out register, status register, control register
	- typically 1-4 bytes, or FIFO buffer
- *your physical hardware should be addressable in the software space*
- devices have addresses, used by
	- direct I/O instructions
	- memory mapped I/O
		- device data and command registers are mapped to processor address space
		- especially for large address spaces
# Polling
- a form of getting input from a particular buffer	
- like asking for new info every n seconds	
- higher polling rate = fresher data
	- input latency is better
	- but consumes more CPU cycles
	- computer will be more busier polling for more input
- for each byte of I/O
	- reads busy bit from status register until 0
	- host sets read or write bit and if write, copies data...
# Interrupts
- polling can happen in 3 instruction cycles
	- read status, logical-and to extract status bit, branch if not zero
	- how to be more efficient if non-zero infrequently?
- CPU interrupt-request line triggered by I/O device
	- checking by processor after each instruction
- interrupt handler receives interrupts
	- maskable to ignore or delay some interrupts
- interrupt vector to dispatch interrupt to correct handler
	- context switch at start and end
	- based on priority
	- some nonmaskable
	- interrupt chaining if more than one device at same interrupt number
- tells the computer "wait, there's something going on!"
- these are like try-catches where if an error happens, it catches that and returns that to the user
![[Pasted image 20250611081211.png]]
- interrupt mechanisms also used for exceptions
- terminate process, crash system due to hardware error
- page fault executes when memory access error
- system call executes via trap to trigger kernel to execute request
- multi-CPU systems can process interrupts concurrently
	- if OS designed to handle it
	- used for time-sensitive processing, frequent, must be fast
# Direct Memory Access
- used to avoid programmed I/O (one byte at a time) for large data movement
- requires DMA controller
- bypasses CPU to transfer data directly between I/O device and memory
- OS writes DMA command block into memory
	- source and destination addresses
	- read or write mode
	- count of bytes
	- writes location of command block to DMA controller
	- bus mastering of DMA controller - **grabs bus from CPU**
	- cycle stealing from CPU but still much more efficient
	- when done, **interrupts** to signal completion
- version that is aware of virtual addresses can be even more efficient - DVMA
# Characteristics of I/O Devices
![[Pasted image 20250611082946.png]]

- subtleties of devices handled by device drivers
- broadly I/O devices can be grouped by the OS into
	- block I/O
	- character I/O
	- memory-mapped file access
	- network sockets
- for direct manipulation of I/O device specific tasks
# Clocks and Timers
- provide current time, elapsed time, timer
- normal resolution about 1/60 seconds
- some systems provide higher-resolution timers
- programmable interval timer used for timings, periodic interrupts
- ioctl() (on UNIX) covers odd aspects of I/O such as clocks and timers