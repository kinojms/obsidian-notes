- I/O Management is a major component of OS design and operation
	- important aspect of computer operation
	- I/O devices can vary
	- various methods to control them
	- performance management (polling rate)
	- new types of devices frequent
- ports, busses, device controllers connect to various devicesâ€”these devices aren't directly connected to the processor, the **device drivers** are the ones connected to the processor
- **Device Drivers** - encapsulate device details
	- present uniform device-access interface to I/O subsystem

- incredible variety
	- storage
	- transmission
	- human-interface
- common concepts - signals from I/O devices interface with computer
	- port - connection point for device (not related to the networking kind of port)
	- bus - daisy chain or shared direct access
		- it's like a highway from the connection point to your processor
		- **bifurcation** - allows a single PCIe slot on a motherboard to be split into multiple smaller lane configurations
- controller (host adapter) - electronics that operate port, bus, device
	- sometimes integrates
	- sometimes separate circuit board
		- in certain architecture, you might want to add additional NVMe's
	- contains processor, microcode, private memory, etc.
	- USB hubs are an example where it becomes a kind of multiplexer for external USB devices (multiple input - one output)
- Fibre channel (FC) is a complex controller, usually separate circuit board (host-bus adapter, HBA plugging into bus)
- I/O instructions control devices
- devices usually registers where device driver places commands, addresses, and data to write, or read data from registers after command execution
	- data-in register, data-out register, status register, control register
	- typically 1-4 bytes, or FIFO buffer
- *your physical hardware should be addressable in the software space*
- devices have addresses, used by
	- direct I/O instructions
	- memory mapped I/O
		- device data and command registers are mapped to processor address space
		- especially for large address spaces
# Polling
- a form of getting input from a particular buffer	
- like asking for new info every n seconds	
- higher polling rate = fresher data
	- input latency is better
	- but consumes more CPU cycles
	- computer will be more busier polling for more input
- for each byte of I/O
	- reads busy bit from status register until 0
	- host sets read or write bit and if write, copies data...
# Interrupts
- polling can happen in 3 instruction cycles
	- read status, logical-and to extract status bit, branch if not zero
	- how to be more efficient if non-zero infrequently?
- CPU interrupt-request line triggered by I/O device
	- checking by processor after each instruction
- interrupt handler receives interrupts
	- maskable to ignore or delay some interrupts
- interrupt vector to dispatch interrupt to correct handler
	- context switch at start and end
	- based on priority
	- some nonmaskable
	- interrupt chaining if more than one device at same interrupt number
- tells the computer "wait, there's something going on!"
- these are like try-catches where if an error happens, it catches that and 